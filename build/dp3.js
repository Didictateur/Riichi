/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/deck.ts":
/*!*********************!*\
  !*** ./src/deck.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deck: () => (/* binding */ Deck)\n/* harmony export */ });\n/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile */ \"./src/tile.ts\");\n/* harmony import */ var _hand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hand */ \"./src/hand.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar Deck = /** @class */ (function () {\n    function Deck(allowRed) {\n        this.tiles = [];\n        this.initTiles(allowRed);\n    }\n    Deck.prototype.displayFamilies = function (ctx, x, y, size, xOffset, yOffset) {\n        if (xOffset === void 0) { xOffset = 0; }\n        if (yOffset === void 0) { yOffset = 0; }\n        var posX = x;\n        var posY = y;\n        for (var i = 1; i < 6; i++) {\n            if (i < 4) { // famille\n                for (var j = 1; j < 10; j++) {\n                    var tile = this.find(i, j);\n                    tile.drawTile(ctx, posX, posY, size, false, 0, false);\n                    posX += (75 + xOffset) * size;\n                }\n                posX = x;\n                posY += (100 + yOffset) * size;\n            }\n            else if (i === 4) { //vent\n                for (var j = 1; j < 5; j++) {\n                    var tile = this.find(i, j);\n                    tile.drawTile(ctx, posX, posY, size);\n                    posX += (75 + xOffset) * size;\n                }\n                posX = x;\n                posY += (100 + yOffset) * size;\n            }\n            else if (i === 5) { //vent\n                for (var j = 1; j < 4; j++) {\n                    var tile = this.find(i, j);\n                    tile.drawTile(ctx, posX, posY, size);\n                    posX += (75 + xOffset) * size;\n                }\n            }\n        }\n    };\n    Deck.prototype.length = function () {\n        return this.tiles.length;\n    };\n    Deck.prototype.pop = function () {\n        if (this.tiles.length === 0) {\n        }\n        return this.tiles.pop();\n    };\n    Deck.prototype.push = function (tile) {\n        this.tiles.push(tile);\n    };\n    Deck.prototype.find = function (family, value) {\n        var _a;\n        var n = undefined;\n        for (var i = 0; i < this.tiles.length; i++) {\n            if (this.tiles[i].getFamily() === family &&\n                this.tiles[i].getValue() === value) {\n                n = i;\n            }\n        }\n        if (n !== undefined) {\n            _a = [this.tiles[0], this.tiles[n]], this.tiles[n] = _a[0], this.tiles[0] = _a[1];\n            return this.tiles.shift();\n        }\n        else {\n            return undefined;\n        }\n    };\n    Deck.prototype.count = function (family, value) {\n        var n = 0;\n        for (var i = 0; i < this.tiles.length; i++) {\n            if (this.tiles[i].getFamily() === family &&\n                this.tiles[i].getValue() === value) {\n                n++;\n            }\n        }\n        return n;\n    };\n    Deck.prototype.shuffle = function () {\n        var _a;\n        var newArray = [];\n        while (this.tiles.length > 0) {\n            var n = Math.floor(Math.random() * this.tiles.length);\n            _a = [this.tiles[0], this.tiles[n]], this.tiles[n] = _a[0], this.tiles[0] = _a[1];\n            newArray.push(this.tiles.shift());\n        }\n        this.tiles = newArray;\n    };\n    Deck.prototype.getRandomHand = function () {\n        var hand = new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand();\n        this.shuffle();\n        for (var i = 0; i < 13; i++) {\n            hand.push(this.pop());\n        }\n        return hand;\n    };\n    Deck.prototype.cleanup = function () {\n        this.tiles.forEach(function (tile) { return tile.cleanup(); });\n        this.tiles = [];\n    };\n    Deck.prototype.preload = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < this.tiles.length)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, this.tiles[i].preloadImg()];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Deck.prototype.initTiles = function (allowRed) {\n        for (var i = 1; i < 6; i++) {\n            if (i < 4) { // famille\n                for (var j = 1; j < 10; j++) {\n                    this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    if (j === 5 && allowRed) {\n                        this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, true));\n                    }\n                    else {\n                        this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    }\n                }\n            }\n            else if (i === 4) { // vent\n                for (var j = 1; j < 5; j++) {\n                    for (var k = 0; k < 4; k++) {\n                        this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    }\n                }\n            }\n            else if (i === 5) { // dragon\n                for (var j = 1; j < 4; j++) {\n                    for (var k = 0; k < 4; k++) {\n                        this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(i, j, false));\n                    }\n                }\n            }\n        }\n    };\n    return Deck;\n}());\n\n\n\n//# sourceURL=webpack:///./src/deck.ts?");

/***/ }),

/***/ "./src/display/dp3.ts":
/*!****************************!*\
  !*** ./src/display/dp3.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanup: () => (/* binding */ cleanup),\n/* harmony export */   initDisplay: () => (/* binding */ initDisplay)\n/* harmony export */ });\n/* harmony import */ var _deck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deck */ \"./src/deck.ts\");\n/* harmony import */ var _hand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hand */ \"./src/hand.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n// Configuration globale\nvar CANVAS_ID = \"myCanvas\";\nvar BG_COLOR = \"#007730\";\nvar BG_RECT = { x: 50, y: 50, w: 1000, h: 1000 };\nvar FPS = 30;\nvar FRAME_INTERVAL = 1000 / FPS;\n// variables globales\nvar DECKS = [];\nvar HANDS = [];\nvar selectedTile = undefined;\n// Optimisation des références\nvar animationFrameId;\nvar lastFrameTime = 0;\nvar callbacks = [];\n// Pré-calcul des dimensions\nvar canvas = document.getElementById(CANVAS_ID);\nvar ctx = canvas.getContext(\"2d\");\n// Cache statique\nvar staticCanvas = document.createElement('canvas');\nvar staticCtx = staticCanvas.getContext(\"2d\");\nstaticCanvas.width = canvas.width;\nstaticCanvas.height = canvas.height;\n// Pré-rendu du fond\nfunction prerenderBackground() {\n    staticCtx.clearRect(0, 0, canvas.width, canvas.height);\n    staticCtx.fillStyle = BG_COLOR;\n    staticCtx.fillRect(BG_RECT.x, BG_RECT.y, BG_RECT.w, BG_RECT.h);\n}\n;\nfunction drawFrame() {\n    if (!ctx)\n        return;\n    // Effacement intelligent (uniquement la zone nécessaire)\n    prerenderBackground();\n    // Ici viendrait le dessin des éléments dynamiques\n    // Par exemple:\n    // drawDeck();\n    // drawHands();\n    var x = 300;\n    var y = 150;\n    var xos = 250;\n    var yos = 100;\n    var size = 0.75;\n    staticCtx.fillStyle = \"#DFDFFF\";\n    staticCtx.font = \"50px serif\";\n    staticCtx.fillText(\"Chii:\", 75, y + 100 * size - 5);\n    HANDS[0].drawHand(staticCtx, x, y, 5, 0.75); // chii\n    HANDS[1].drawHand(staticCtx, x + (75 + xos) * size, y, 5, 0.75);\n    staticCtx.fillText(\"Pon:\", 75, y + (100 + yos) * size + 100 * size - 5);\n    HANDS[2].drawHand(staticCtx, x, y + (100 + yos) * size, 5, 0.75); // pon\n    HANDS[3].drawHand(staticCtx, x + (75 + xos) * size, y + (100 + yos) * size, 5, 0.75);\n    HANDS[4].drawHand(staticCtx, x + 2 * (75 + xos) * size, y + 2 * (100 + yos) * size, 5, 0.75);\n    staticCtx.fillText(\"Invalide:\", 75, y + 2 * (100 + yos) * size + 100 * size - 5);\n    HANDS[5].drawHand(staticCtx, x, y + 2 * (100 + yos) * size, 5, 0.75); // wrong\n    HANDS[6].drawHand(staticCtx, x + (75 + xos) * size, y + 2 * (100 + yos) * size, 5, 0.75);\n    HANDS[7].drawHand(staticCtx, x + 2 * (75 + xos) * size, y + 2 * (100 + yos) * size, 5, 0.75);\n    HANDS[8].isolate = true;\n    HANDS[8].drawHand(staticCtx, 100, 800, 5, size, selectedTile);\n    var groups = HANDS[8].toGroup();\n    if (groups !== undefined) {\n        staticCtx.fillStyle = \"#FF0000\";\n        staticCtx.font = \"50px serif\";\n        staticCtx.fillText(\"Tous les groupes sont formés !\", 100, 750);\n    }\n    groups = [];\n    // Dessin du cache statique\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.drawImage(staticCanvas, 0, 0);\n}\nfunction animationLoop(currentTime) {\n    animationFrameId = requestAnimationFrame(animationLoop);\n    var deltaTime = currentTime - lastFrameTime;\n    if (deltaTime < FRAME_INTERVAL)\n        return;\n    lastFrameTime = currentTime - (deltaTime % FRAME_INTERVAL);\n    drawFrame();\n}\nfunction initEventListeners() {\n    var handlers = {\n        mousemove: function (e) {\n            var size = 0.75;\n            var x = 100;\n            // Logique de gestion du mouvement de la souris\n            var rect = canvas.getBoundingClientRect();\n            var mouseX = e.clientX - rect.left - x;\n            var mouseY = e.clientY - rect.top;\n            var q = Math.floor(mouseX / (80 * size));\n            var r = mouseX - q * 80 * size;\n            if (r <= 75 && q >= 0 && q < 14 && mouseY >= 800 && mouseY <= 800 + 100 * size) {\n                selectedTile = q;\n            }\n            else {\n                selectedTile = undefined;\n            }\n        },\n        mousedown: function (e) {\n            // Logique de gestion du clic de souris\n            if (selectedTile !== undefined) {\n                DECKS[0].push(HANDS[8].eject(selectedTile));\n                DECKS[0].shuffle();\n                HANDS[8].sort();\n                HANDS[8].push(DECKS[0].pop());\n            }\n        }\n    };\n    callbacks.push(function () {\n        canvas.removeEventListener('mousemove', handlers.mousemove);\n        canvas.removeEventListener('mousedown', handlers.mousedown);\n    });\n    canvas.addEventListener('mousemove', handlers.mousemove);\n    canvas.addEventListener('mousedown', handlers.mousedown);\n}\nfunction preloadDeck(deck) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, deck.preload()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction preloadHand(hand) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, hand.preload()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction cleanup() {\n    cancelAnimationFrame(animationFrameId);\n    callbacks.forEach(function (fn) { return fn(); });\n}\nfunction initDisplay() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!ctx) {\n                        console.error(\"Context canvas indisponible\");\n                        return [2 /*return*/];\n                    }\n                    // Préchargement des ressources si nécessaire\n                    // const deck = new Deck();\n                    // await preloadDeck(deck);\n                    DECKS.push(new _deck__WEBPACK_IMPORTED_MODULE_0__.Deck(false));\n                    HANDS.push(new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"s1s2s3\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"m2m3m4\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"p5p5p5\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"w2w2w2\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"d3d3d3\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"s4p5m6\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"m9s9p9\"), new _hand__WEBPACK_IMPORTED_MODULE_1__.Hand(\"d1d2d3\"), DECKS[0].getRandomHand());\n                    return [4 /*yield*/, Promise.all(DECKS.map(function (d) { return preloadDeck(d); }))];\n                case 1:\n                    _a.sent();\n                    return [4 /*yield*/, Promise.all(HANDS.map(function (h) { return preloadHand(h); }))];\n                case 2:\n                    _a.sent();\n                    HANDS[8].push(DECKS[0].pop());\n                    HANDS[8].sort();\n                    initEventListeners();\n                    requestAnimationFrame(animationLoop);\n                    window.cleanup = cleanup;\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n// Initialisation automatique si le script est chargé directement\nif (typeof window !== 'undefined') {\n    initDisplay().catch(console.error);\n}\n\n\n//# sourceURL=webpack:///./src/display/dp3.ts?");

/***/ }),

/***/ "./src/group.ts":
/*!**********************!*\
  !*** ./src/group.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Group: () => (/* binding */ Group)\n/* harmony export */ });\nvar Group = /** @class */ (function () {\n    function Group(tiles, stolenFrom, belongsTo) {\n        this.tiles = tiles;\n        this.stolenFrom = stolenFrom;\n        this.belongsTo = belongsTo;\n    }\n    Group.prototype.push = function (tile) {\n        this.tiles.push(tile);\n    };\n    Group.prototype.pop = function () {\n        return this.tiles.pop();\n    };\n    Group.prototype.getTiles = function () {\n        return this.tiles;\n    };\n    Group.prototype.compare = function (g) {\n        var c = this.tiles[0].compare(g.tiles[0]);\n        if (c !== 0) {\n            return c;\n        }\n        return this.tiles[1].compare(g.tiles[1]);\n    };\n    Group.prototype.drawGroup = function (ctx, x, y, os, size, rotation, selectedTile) {\n        ctx.save();\n        ctx.translate(525, 525);\n        ctx.rotate(rotation);\n        ctx.translate(-525, -525);\n        rotation = 0;\n        var v = 75 * size;\n        var w = 90 * size;\n        var osy = 25 * size / 2;\n        var p = (this.belongsTo - this.stolenFrom - 1 + 4) % 4;\n        var sf = selectedTile === undefined ? -1 : selectedTile.getFamily();\n        var sv = selectedTile === undefined ? 0 : selectedTile.getValue();\n        if (p === 0) {\n            this.tiles[0].drawTile(ctx, x, y + osy, size, false, 3.141592 / 2, this.tiles[0].isEqual(sf, sv));\n            this.tiles[1].drawTile(ctx, x + w, y, size, false, 0, this.tiles[1].isEqual(sf, sv));\n            this.tiles[2].drawTile(ctx, x + w + v + os * size, y, size, false, 0, this.tiles[2].isEqual(sf, sv));\n        }\n        else if (p === 1) {\n            this.tiles[0].drawTile(ctx, x, y, size, false, 0, this.tiles[0].isEqual(sf, sv));\n            this.tiles[1].drawTile(ctx, x + w, y + osy, size, false, 0 - 3.141592 / 2, this.tiles[1].isEqual(sf, sv));\n            this.tiles[2].drawTile(ctx, x + w + v + 3 * os * size, y, size, false, 0, this.tiles[2].isEqual(sf, sv));\n        }\n        else if (p === 2) {\n            this.tiles[0].drawTile(ctx, x, y, size, false, 0, this.tiles[0].isEqual(sf, sv));\n            this.tiles[1].drawTile(ctx, x + v + os * size, y, size, false, 0, this.tiles[1].isEqual(sf, sv));\n            this.tiles[2].drawTile(ctx, x + w + v + os * size, y + osy, size, false, 0 - 3.141592 / 2, this.tiles[2].isEqual(sf, sv));\n        }\n        else {\n            //TODO error\n        }\n        ctx.restore();\n    };\n    return Group;\n}());\n\n\n\n//# sourceURL=webpack:///./src/group.ts?");

/***/ }),

/***/ "./src/hand.ts":
/*!*********************!*\
  !*** ./src/hand.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hand: () => (/* binding */ Hand)\n/* harmony export */ });\n/* harmony import */ var _tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tile */ \"./src/tile.ts\");\n/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group */ \"./src/group.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\nvar Hand = /** @class */ (function () {\n    function Hand(stiles) {\n        if (stiles === void 0) { stiles = \"\"; }\n        this.isolate = false;\n        this.tiles = [];\n        for (var i = 0; 2 * i + 1 < stiles.length; i++) {\n            var ss = stiles.substring(2 * i, 2 * (i + 1));\n            if (ss[0] === \"m\") {\n                this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(1, Number(ss[1]), false));\n            }\n            else if (ss[0] === \"p\") {\n                this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(2, Number(ss[1]), false));\n            }\n            else if (ss[0] === \"s\") {\n                this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(3, Number(ss[1]), false));\n            }\n            else if (ss[0] === \"w\") {\n                this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(4, Number(ss[1]), false));\n            }\n            else if (ss[0] === \"d\") {\n                this.tiles.push(new _tile__WEBPACK_IMPORTED_MODULE_0__.Tile(5, Number(ss[1]), false));\n            }\n            else { }\n        }\n    }\n    Hand.prototype.getTiles = function () {\n        return this.tiles;\n    };\n    Hand.prototype.length = function () {\n        return this.tiles.length;\n    };\n    Hand.prototype.push = function (tile) {\n        this.tiles.push(tile);\n    };\n    Hand.prototype.pop = function () {\n        return this.tiles.pop();\n    };\n    Hand.prototype.find = function (family, value) {\n        var _a;\n        var n = undefined;\n        for (var i = 0; i < this.tiles.length; i++) {\n            if (this.tiles[i].getFamily() === family && this.tiles[i].getValue() === value) {\n                n = i;\n                break;\n            }\n        }\n        if (n !== undefined) {\n            _a = [this.tiles[0], this.tiles[n]], this.tiles[n] = _a[0], this.tiles[0] = _a[1];\n            var t = this.tiles.shift();\n            this.sort();\n            return t;\n        }\n        else {\n            return undefined;\n        }\n    };\n    Hand.prototype.eject = function (idTile) {\n        var _a;\n        _a = [this.tiles[idTile], this.tiles[0]], this.tiles[0] = _a[0], this.tiles[idTile] = _a[1];\n        var tile = this.tiles.shift();\n        this.sort();\n        return tile;\n    };\n    Hand.prototype.get = function (idTile) {\n        if (idTile !== undefined) {\n            return this.tiles[idTile];\n        }\n        else {\n            return undefined;\n        }\n    };\n    Hand.prototype.sort = function () {\n        this.tiles.sort(function (a, b) { return a.isLessThan(b) ? -1 : 1; });\n    };\n    Hand.prototype.count = function (family, value) {\n        var c = 0;\n        this.tiles.forEach(function (t) {\n            if (t.getFamily() === family && t.getValue() === value) {\n                c++;\n            }\n        });\n        return c;\n    };\n    Hand.prototype.toGroup = function (pair) {\n        if (pair === void 0) { pair = false; }\n        if (this.tiles.length > 0) {\n            var t1 = this.tiles.pop();\n            var c = this.count(t1.getFamily(), t1.getValue());\n            if (c >= 1 && !pair) { //can do a pair\n                var t2 = this.find(t1.getFamily(), t1.getValue());\n                var groups = this.toGroup(true);\n                this.tiles.push(t2);\n                this.sort();\n                if (groups !== undefined) {\n                    this.tiles.push(t1);\n                    this.sort();\n                    groups.push(new _group__WEBPACK_IMPORTED_MODULE_1__.Group([t1, t2], 0, 0));\n                    return groups;\n                }\n            }\n            if (c >= 2) { //can do a pon\n                var t2 = this.find(t1.getFamily(), t1.getValue());\n                var t3 = this.find(t1.getFamily(), t1.getValue());\n                var groups = this.toGroup(pair);\n                this.tiles.push(t2);\n                this.tiles.push(t3);\n                this.sort();\n                if (groups !== undefined) {\n                    groups.push(new _group__WEBPACK_IMPORTED_MODULE_1__.Group([t1, t2, t3], 0, 0));\n                    this.tiles.push(t1);\n                    this.sort();\n                    return groups;\n                }\n            }\n            var c2 = this.count(t1.getFamily(), t1.getValue() - 1);\n            var c3 = this.count(t1.getFamily(), t1.getValue() - 2);\n            if (c2 * c3 > 0) { //can do a chii\n                var t2 = this.find(t1.getFamily(), t1.getValue() - 1);\n                var t3 = this.find(t1.getFamily(), t1.getValue() - 2);\n                var groups = this.toGroup(pair);\n                this.tiles.push(t2);\n                this.tiles.push(t3);\n                this.sort();\n                if (groups !== undefined) {\n                    groups.push(new _group__WEBPACK_IMPORTED_MODULE_1__.Group([t3, t2, t1], 0, 0));\n                    this.tiles.push(t1);\n                    this.sort();\n                    return groups;\n                }\n            }\n            this.tiles.push(t1);\n            this.tiles.sort();\n        }\n        else {\n            return [];\n        }\n        return undefined;\n    };\n    Hand.prototype.drawHand = function (ctx, x, y, offset, size, focusedTiled, hidden, rotation) {\n        if (focusedTiled === void 0) { focusedTiled = undefined; }\n        if (hidden === void 0) { hidden = false; }\n        if (rotation === void 0) { rotation = 0; }\n        var v = (75 + offset) * size;\n        var vx = Math.cos(rotation) * v;\n        var vy = Math.sin(rotation) * v;\n        for (var i = 0; i < this.tiles.length; i++) {\n            var e = (i === this.tiles.length - 1 && this.isolate) ? 10 : 0;\n            if (i === focusedTiled) {\n                this.tiles[i].drawTile(ctx, x +\n                    i * vx +\n                    25 * size * Math.sin(rotation) +\n                    e * size * Math.cos(rotation), y +\n                    i * vy -\n                    25 * size * Math.cos(rotation) +\n                    e * size * Math.sin(rotation), size, hidden, rotation);\n            }\n            else {\n                this.tiles[i].drawTile(ctx, x + i * vx + e * size * Math.cos(rotation), y + i * vy + e * size * Math.sin(rotation), size, hidden, rotation);\n            }\n        }\n    };\n    Hand.prototype.preload = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all(this.tiles.map(function (t) { return t.preloadImg(); }))];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Hand.prototype.cleanup = function () {\n        this.tiles.forEach(function (tile) { return tile.cleanup(); });\n        this.tiles = [];\n    };\n    return Hand;\n}());\n\n\n\n//# sourceURL=webpack:///./src/hand.ts?");

/***/ }),

/***/ "./src/tile.ts":
/*!*********************!*\
  !*** ./src/tile.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tile: () => (/* binding */ Tile)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar Tile = /** @class */ (function () {\n    function Tile(family, value, red) {\n        this.family = family;\n        this.value = value;\n        this.red = red;\n        this.imgSrc = \"\";\n        this.imgFront = new Image();\n        this.imgBack = new Image();\n        this.imgGray = new Image();\n        this.img = new Image();\n        this.tilt = 0;\n        this.setImgSrc();\n    }\n    Tile.prototype.getFamily = function () {\n        return this.family;\n    };\n    Tile.prototype.getValue = function () {\n        return this.value;\n    };\n    Tile.prototype.isEqual = function (family, value) {\n        return this.family === family && this.value === value;\n    };\n    Tile.prototype.isRed = function () {\n        return this.red;\n    };\n    Tile.prototype.compare = function (t) {\n        if (this.family < t.family) {\n            return -1;\n        }\n        else if (this.family > t.family) {\n            return 1;\n        }\n        if (this.value < t.value) {\n            return -1;\n        }\n        else if (this.value > t.value) {\n            return 1;\n        }\n        return 0;\n    };\n    Tile.prototype.setTilt = function () {\n        this.tilt = (1 - 2 * Math.random()) * 0.04;\n    };\n    Tile.prototype.drawTile = function (ctx, x, y, size, hidden, rotation, gray, tilted) {\n        if (hidden === void 0) { hidden = false; }\n        if (rotation === void 0) { rotation = 0; }\n        if (gray === void 0) { gray = false; }\n        if (tilted === void 0) { tilted = true; }\n        ctx.save();\n        ctx.translate(x + (75 * size) / 2, y + (100 * size) / 2);\n        if (tilted) {\n            ctx.rotate(rotation + this.tilt);\n        }\n        if (hidden) {\n            ctx.drawImage(// ombre\n            this.imgGray, -(75 * size * 0.92) / 2, -(100 * size * 0.91) / 2, 75 * size, 100 * size);\n            ctx.drawImage(// le dos des tuiles\n            this.imgBack, -(75 * size) / 2, -(100 * size) / 2, 75 * size, 100 * size);\n        }\n        else {\n            ctx.drawImage(// ombre\n            this.imgGray, -(75 * size * 0.92) / 2, -(100 * size * 0.91) / 2, 75 * size, 100 * size);\n            ctx.drawImage(// tuile à vide\n            this.imgFront, -(75 * size) / 2, -(100 * size) / 2, 75 * size, 100 * size);\n            ctx.drawImage(// le dessin sur la tuile\n            this.img, -((75 - 7) * size) / 2, -((100 - 10) * size) / 2, 75 * size * 0.9, 100 * size * 0.9);\n            if (gray) { // grisé\n                ctx.drawImage(this.imgGray, -(75 * size) / 2, -(100 * size) / 2, 75 * size, 100 * size);\n            }\n        }\n        ctx.restore();\n    };\n    Tile.prototype.isLessThan = function (t) {\n        if (this.family < t.family) {\n            return true;\n        }\n        else if (this.family === t.family && this.value <= t.value) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Tile.prototype.cleanup = function () {\n        this.imgFront.onload = null;\n        this.imgFront.onerror = null;\n        this.imgBack.onload = null;\n        this.imgBack.onerror = null;\n        this.imgGray.onload = null;\n        this.imgGray.onerror = null;\n        this.img.onload = null;\n        this.img.onerror = null;\n    };\n    Tile.prototype.setImgSrc = function () {\n        this.imgSrc = \"img/Regular/\";\n        if (this.family <= 3) {\n            this.imgSrc += [\"\", \"Man\", \"Pin\", \"Sou\"][this.family];\n            this.imgSrc += String(this.value);\n            if (this.red) {\n                this.imgSrc += \"-Dora\";\n            }\n            this.imgSrc += \".svg\";\n        }\n        else if (this.family === 4) {\n            this.imgSrc += [\"\", \"Ton\", \"Nan\", \"Shaa\", \"Pei\"][this.value] + \".svg\";\n        }\n        else if (this.family === 5) {\n            this.imgSrc += [\"\", \"Chun\", \"Hatsu\", \"Haku\"][this.value] + \".svg\";\n        }\n    };\n    Tile.prototype.preloadImg = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.loadImg(this.imgFront, \"img/Regular/Front.svg\"),\n                            // this.loadImg(this.imgFront, \"/~img/Export/Regular/Front.png\"),\n                            this.loadImg(this.imgBack, \"img/Regular/Back.svg\"),\n                            this.loadImg(this.imgGray, \"img/Regular/Gray.svg\"),\n                            this.loadImg(this.img, this.imgSrc)\n                        ])];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Tile.prototype.loadImg = function (img, src) {\n        return new Promise(function (resolve, reject) {\n            img.onload = function () { return resolve(); };\n            img.onerror = function () { return reject(); };\n            img.src = src;\n        });\n    };\n    return Tile;\n}());\n\n\n\n//# sourceURL=webpack:///./src/tile.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/display/dp3.ts");
/******/ 	
/******/ })()
;